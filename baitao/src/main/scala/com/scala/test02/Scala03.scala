package com.scala.test02

object Scala03 {
  def main(args: Array[String]): Unit = {
  //函数作为返回值方式一=======================================
//    def t1( i : Int , j : Int) = {
//          i * j
//    }
//
//    def t2() = {
//      t1 _
//    }
//
//    val a = t2() //返回内部t1函数
//    println(a(10, 20))

    //函数作为返回值方式二=======================================
//    def t1( i : Int , j : Int) = {
//      i * j
//    }
//
//    def t2() = {
//      t1 _
//    }
//
//    println(  t2()(10, 20)  ) //连续调用

    //==========================================================
    // 可以连续嵌套，实现多层函数作为返回值。
//    def f1()  = {
//
//        def f2(i: Int, j: Int) = {
//               i * j
//         }
//
//         f2 _
//
//    }
//
//    println( f1()(10, 15) )

//=================================================================
//也可以省略下划线，但要在外层函数显示声名返回值类型
//    def f1() : (Int , Int) => Int = {
//
//      def f2(i: Int, j: Int) = {
//        i * j
//      }
//
//      f2
//
//    }
//
//    println( f1()(10, 15) )
//=============================================================

//    def f1( s : String) = {
//
//
//      def f2(i: Int, j: Int) = {
//        i * j
//      }
//
//      f2 _
//      s
//
//    }
//
//    println( f1("lisi") )
//==================================================
// 传参例题。压栈 --> 弹栈 ：内层函数在使用外层函数的参数时，如果该参数失效时，会将
//此参数包装到内部函数中，形成闭合效果，增加此参数的声名周期 ，叫做close （闭包）。
//在Scala2.12版本中，编译器发现，
// 内部函数的参数又重新声名了一次外部的那个参数 ，使之变成自己的了。
//在早期版本中 ， 是创建了一个新的匿名函数类，把参数放在类的属性里，让内层函数调用。
// 匿名函数、将函数赋值给变量、嵌套函数并且用得到了内部函数，就会有闭包。
//    def f1(k : Int)  = {
//
//      def f2(i: Int, j: Int) = {
//        i * j * k
//     }
//
//       f2 _
//
//    }
//
//    println( f1(2)(10, 15) )
//======================================================
    //柯里化,多个参数列表 ，简化嵌套
    //可以连续设置多个参数列表括号，类似每个列表代表着一层嵌套函数。
//    def t1 ()(i : Int , j : Int) = {
//           i * j
//    }
//
//    println(   t1()(2, 3)   )

//    def t1 ()(i : Int)( j : Int , k : Int)  = {
//      i * j * k
//    }
//
//    println(   t1()(2)(3,4)   )
//=============================================================
    //柯里化加匿名函数
//    def t1 (i: Int) (j : Int) ( f : (Int , Int) => Int ) = {
//        f(i ,j )
//    }
//
//    println( t1(2)(3)(_ + _) )

//=================================================================
    //抽象控制
    //可以将代码当作参数传给函数，如果有多条代码逻辑 需要大括号传入代码参数 test { 代码 }
    // 抽象控制函数的声名方式 ： def test (f : => 返回值类型比如unit) = { f }   i为需要的代码参数

//    def t1( f : => Unit ) = {
//          f
//    }
//
//     t1{
//
//      for (i <- 1 to( 5 )){
//        println(i)
//      }
//
//       }
//=====================================================
    //下面有点懵，传参和抽象控制
//    def t1( f : => Int ) = {
//
//          f
//  }
//
//  def fun(i: Int) = {
//    i * i
//  }
//
//  println( t1 {
//    fun(5)
//  })

//  def fun( i : Int) = {
//      i * i
//  }
//
//    def test(f :  Int) = {
//        f
//    }
//
//    println(test(fun(5)))
//
//
//    def fun( i : Int) = {
//      i * i
//    }
//
//    def test(f : => Int) = {
//      f
//    }
//
//    println(test(fun(5)))
//
//
//    def test(f : (Int) => Int) = {
//            f(5)
//    }
//
//    println( test((i: Int) => i * i) )

//======================================================
    //递归 ： 注意：递归函数的返回值必须明确指定
    //递归，但是如果无限循环或者循环次数过多，会出现stackOverflowError 栈溢出
    //递归需要明确返回值类型
    //1+3+5+7+9.。。。
    //    def t2 ( j : Int) : Int = {
    //
    //      if( j == 1){
    //          1
    //      }else{
    //        j + t2( j - 2 )
    //      }
    //
    //    }
    //
    //    println(t2(13))

//======================================================
    //求阶乘，但是无法求数据大的，因为循环次数过多，是普通递归
//    def t1(i : Int):Int = {
//
//      if( i == 1){
//          1
//      }else{
//         i * t1( i -1 )
//      }
//
//    }
//========================================================
    //解决循环次数过多，栈内存溢出的方法。
    //因为当一次循环未结束，就调用下一次，方法压着不释放。
    //尾递归
//    def t1(i : Int):Int = {
//
//      if( i == 1){
//        1
//      }else{
//         t1( i -1 ) //这样可以，因为此循环不会依赖下一个方法
//      }
//
//    }
//-------------------------------------------
//    def t1(i : Int):Int = {
//
//      if( i == 1){
//        1
//      }else{
//        t1( i -1 ) //这样可以，因为此循环不会依赖下一个方法
//      }
//
//    }
//--------------------------------------------------
//下面通过改变执行顺序，也可以切换普通递归和尾递归（编译器自动优化为while循环）
//  def t1():Unit = {
//
//    t1()
//
//    println("xxxxxx")
//  }
//----------------------------------------------
//尾递归
//   def t1(i : Int , result : Int): Int = {
//
//     if( i == 1){
//        result
//     }else{
//        t1( i - 1 , i + result)
//     }
//
//
//   }

//    t1(5 , 1) 计算5递归

//================================================
   // 惰性函数 ：不执行函数内容，除非去接收了函数结果
//   def t1(int: Int):Int = {
//
//     println("xxxxxx")
//     int
//   }
//
//    lazy val a: Int = t1(10)
//    println("-----------")
//    println(a)



  }
}

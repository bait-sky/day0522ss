package com.scala.test01

object Scala02 {
  def main(args: Array[String]): Unit = {

    //============================================
    // 将函数作为整体，被另一个函数返回。
//    def test1(i : Int) = {
//
//            i * 2
//
//    }
//
//    def f1() ={
//
//         test1 _
//
//    }
//
//    val a = f1()
//
//    println(a(5))

    //=======================================================
    // 简化 :
//    def test1(i : Int) = {
//
//      i * 2
//
//    }
//
//    def f1() ={
//
//      test1 _
//
//    }
//
//    println( f1()(10) )  //返回值直接调用 f1()(10)

  //======================================================
  //  把需要返回的函数，嵌套在外层函数里，再返回内层函数名 _
//      def fun()  ={
//
//        def test( i : Int) : Int = {
//
//          i * 2
//
//        }
//
//        test _
//      }
//
//    println(fun()(6))
//
    //========================================================
    // 假如内返回的层函数名，不省略下划线 ，必须手动声名外层函数的返回值
//    def fun() : (Int) => Int  = {
//
//      def test( i : Int) : Int = {
//
//        i * 2
//
//      }
//
//      test
//    }
//
//    println(fun()(6))

    //================================================
    // 传参例题。压栈 --> 弹栈 ：内层函数在使用外层函数的参数时，如果该参数失效时，会将
    //此参数包装到内部函数中，形成闭合效果，增加此参数的声名周期 ，叫做close （闭包）。
    //在Scala2.12版本中，编译器发现，
    // 内部函数的参数又重新声名了一次外部的那个参数 ，使之变成自己的了。
    //在早期版本中 ， 是创建了一个新的匿名函数类，把参数放在类的属性里，让内层函数调用。
    // 匿名函数、将函数赋值给变量、嵌套函数并且用得到了内部函数，就会有闭包。
//    def fun ( i : Int ) = {
//
//      def test ( j : Int )  = {
//
//            i + j
//
//      }
//
//            test _
//    }
//
//    println(fun(5)(6))

    //===============================================================
    //


  }

}
